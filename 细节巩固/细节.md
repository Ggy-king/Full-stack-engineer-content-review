### vue的底层;vue23的对比;vue的核心;vue主要做了什么

1. 响应式系统：
    - Vue 2 使用 Object.defineProperty 来追踪数据的变化，并在需要时触发更新。
    - Vue 3 使用 Proxy 对象来实现响应式系统，提供了更高效、更全面的数据拦截机制。
2. 性能优化：
    - Vue 2 通过虚拟 DOM 和 diff 算法来比较新旧虚拟 DOM 树，以最小代价更新真实 DOM。
    - Vue 3 在虚拟 DOM 算法上进行了优化，并引入了静态提升、静态树优化等技术，进一步提高了性能。
3. 代码结构与架构：
    - Vue 2 主要使用 Options API，通过配置对象的方式来定义组件的状态、生命周期钩子、方法等。
    - Vue 3 引入了 Composition API，通过函数的方式来组织逻辑，使得代码更加模块化、可重用。
4. TypeScript 支持：
    - Vue 2 对 TypeScript 的支持相对较弱，需要额外的声明文件来补充类型信息。
    - Vue 3 在设计时就考虑到了 TypeScript 的支持，提供了更好的类型推导和类型检查。

### flex相关内容

一、容器属性（作用于 Flex 容器）
    display
值：flex（块级容器）或 inline-flex（行内容器）
作用：将元素定义为 Flex 容器，触发弹性布局。
    flex-direction
值：row（默认，主轴水平向右）| row-reverse | column | column-reverse
作用：定义主轴（main axis）方向，决定项目排列方向。
    flex-wrap
值：nowrap（默认，不换行）| wrap（换行）| wrap-reverse（反向换行）
作用：控制项目在主轴上是否换行。
    flex-flow
值：<flex-direction> <flex-wrap>（如 row wrap）
作用：flex-direction 和 flex-wrap 的简写属性。
    justify-content
值：flex-start（默认，起点对齐）| flex-end | center | space-between | space-around | space-evenly
作用：定义项目在主轴上的对齐方式。
    align-items
值：stretch（默认，拉伸填满容器）| flex-start | flex-end | center | baseline
作用：定义项目在交叉轴上的对齐方式。
    align-content
值：stretch（默认）| flex-start | flex-end | center | space-between | space-around
作用：当存在多行时，定义行在交叉轴上的对齐方式（单行无效）。
二、项目属性（作用于 Flex 项目）
    order
值：<integer>（默认 0）
作用：定义项目的排列顺序，数值越小越靠前。
    flex-grow
值：<number>（默认 0，不放大）
作用：定义项目的放大比例，剩余空间按比例分配。
    flex-shrink
值：<number>（默认 1，等比收缩）
作用：定义项目的收缩比例，空间不足时按比例缩小。
    flex-basis
值：<length>（如 200px）| auto（默认，项目原始尺寸）
作用：定义项目在分配多余空间前的初始大小。
    flex
值：none | <flex-grow> <flex-shrink> <flex-basis>（如 1 1 200px）
作用：flex-grow, flex-shrink, flex-basis 的简写，常用 flex: 1（等分空间）。
    align-self
值：auto（默认继承容器 align-items）| flex-start | flex-end | center | baseline | stretch
作用：覆盖容器的 align-items，单独定义当前项目的交叉轴对齐方式。
难点注意  flex: 1  === flex: 1 1 0%  <!-- 放大1 缩小1 告诉浏览器不考虑我的尺寸 -->
         flex: auto  === flex: 0 1 auto  <!-- 放大1 缩小1 以项目元素为默认尺寸 -->
         flex: none  === flex: 0 0 auto  <!-- 不允许放大 不允许缩小 以项目元素为默认尺寸 -->


### js事件执行顺序个人理解

- 简单来说就是 同步 -> 微任务 -> 宏任务
- 深度理解：
    执行同步代码，清空调用栈。
    检查微任务队列，清空所有微任务。不管某微任务嵌套多少层，遇微追加微队尾，遇宏追加宏队尾，遇同步直接执行
    取出宏任务队列中的第一个任务执行。不管某宏任务嵌套多少层，遇微追加微队尾，遇宏追加宏队尾，遇同步直接执行

JavaScript 是单线程的，所有同步代码（如变量声明、函数调用）会立即执行，形成执行栈（Call Stack）
宏任务队列看似是“先进先出”，但实际存在隐性优先级规则
1. 宏任务类型与优先级排序
从高到低依次为：

    UI渲染（如浏览器重绘/回流）
    I/O操作（如文件读取、AJAX响应）
    requestAnimationFrame（动画帧更新）
    setTimeout/setInterval（定时器）
    setImmediate（Node.js特有，优先级高于定时器）
    process.nextTick（Node.js微任务，但优先级高于所有宏任务）
2. 浏览器与Node.js的差异
浏览器：
    UI渲染可能插入在两次宏任务之间。
    requestAnimationFrame 专为动画设计，比定时器更频繁触发。
Node.js：
    process.nextTick 是微任务，但优先级高于 Promise。
    setImmediate 是宏任务，但优先级高于 setTimeout