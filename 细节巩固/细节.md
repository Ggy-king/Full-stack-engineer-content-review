# vue的底层;vue23的对比;vue的核心;vue主要做了什么

1. 响应式系统：
    - Vue 2 使用 Object.defineProperty 来追踪数据的变化，并在需要时触发更新。
    - Vue 3 使用 Proxy 对象来实现响应式系统，提供了更高效、更全面的数据拦截机制。
2. 性能优化：
    - Vue 2 通过虚拟 DOM 和 diff 算法来比较新旧虚拟 DOM 树，以最小代价更新真实 DOM。
    - Vue 3 在虚拟 DOM 算法上进行了优化，并引入了静态提升、静态树优化等技术，进一步提高了性能。
3. 代码结构与架构：
    - Vue 2 主要使用 Options API，通过配置对象的方式来定义组件的状态、生命周期钩子、方法等。
    - Vue 3 引入了 Composition API，通过函数的方式来组织逻辑，使得代码更加模块化、可重用。
4. TypeScript 支持：
    - Vue 2 对 TypeScript 的支持相对较弱，需要额外的声明文件来补充类型信息。
    - Vue 3 在设计时就考虑到了 TypeScript 的支持，提供了更好的类型推导和类型检查。

# HTTP 缓存机制个人理解

一、强缓存（强制缓存）

- 定义：浏览器直接使用本地缓存，无需向服务器发送请求验证资源是否更新。
    控制响应头：
1. Expires
    格式：Expires: Wed, 21 Oct 2023 07:28:00 GMT
    缺点：依赖服务器时间，若客户端时间错误会导致缓存失效。
2. Cache-Control（优先级高于 Expires）
    常用值：
    max-age=秒数：资源最大有效时间（从请求时间开始计算）。
    no-cache：强制每次请求需向服务器验证（协商缓存）。
    no-store：禁止缓存任何内容（如敏感数据）。
    public：允许代理服务器和客户端缓存。
    private：仅客户端可缓存。


    Cache-Control: max-age=3600  # 缓存1小时
    首次请求：浏览器缓存资源 + 响应头。
    后续请求：若未过期，直接读取本地缓存（状态码 200，但来自内存/磁盘）。

二、协商缓存（对比缓存）

- 定义：强缓存失效后，浏览器需向服务器发送请求，通过校验资源是否修改来决定使用本地缓存还是新资源。

1. Last-Modified / If-Modified-Since
    流程：
    1. 服务器返回 Last-Modified: 时间戳。
    2. 浏览器下次请求携带 If-Modified-Since: 时间戳。
    3. 服务器对比时间，若未修改返回 304 Not Modified，否则返回新资源。
    缺点：时间精度为秒级，若资源在秒内修改可能无法检测。
2. ETag / If-None-Match（推荐）
    流程：
    1. 服务器生成唯一标识（如文件哈希值）返回 ETag: "abc123"。
    2. 浏览器下次请求携带 If-None-Match: "abc123"。
    3. 服务器对比 ETag，若匹配返回 304，否则返回新资源和新 ETag。
    优点：精度更高，可避免秒级时间误差问题。


    ETag: "6a7d8b9c"
    Last-Modified: Tue, 20 Oct 2023 07:28:00 GMT
 
    - 后续请求（假设未修改）
    If-None-Match: "6a7d8b9c"
    If-Modified-Since: Tue, 20 Oct 2023 07:28:00 GMT
    - 服务器返回 304，浏览器使用本地缓存


三、强缓存 vs 协商缓存
    特性	强缓存	协商缓存
    是否发请求	否	是（但可能返回304）
    控制头	Expires, Cache-Control	ETag, Last-Modified
    优先级	高（直接命中）	低（强缓存失效后触发）
    适用场景	长期不变的静态资源	动态资源或频繁更新的内容


四、最佳实践

- 静态资源（如图片、CSS/JS）：
    设置 Cache-Control: max-age=31536000（1年） + ETag。
- 动态接口：
    使用 Cache-Control: no-cache + ETag，确保每次请求验证。
- 敏感数据：
    添加 Cache-Control: no-store，禁止任何缓存。
- 版本控制：
    在 URL 中添加哈希（如 style.css?v=2），强制更新缓存。



# flex相关内容

一、容器属性（作用于 Flex 容器）
    display
值：flex（块级容器）或 inline-flex（行内容器）
作用：将元素定义为 Flex 容器，触发弹性布局。
    flex-direction
值：row（默认，主轴水平向右）| row-reverse | column | column-reverse
作用：定义主轴（main axis）方向，决定项目排列方向。
    flex-wrap
值：nowrap（默认，不换行）| wrap（换行）| wrap-reverse（反向换行）
作用：控制项目在主轴上是否换行。
    flex-flow
值：<flex-direction> <flex-wrap>（如 row wrap）
作用：flex-direction 和 flex-wrap 的简写属性。
    justify-content
值：flex-start（默认，起点对齐）| flex-end | center | space-between | space-around | space-evenly
作用：定义项目在主轴上的对齐方式。
    align-items
值：stretch（默认，拉伸填满容器）| flex-start | flex-end | center | baseline
作用：定义项目在交叉轴上的对齐方式。
    align-content
值：stretch（默认）| flex-start | flex-end | center | space-between | space-around
作用：当存在多行时，定义行在交叉轴上的对齐方式（单行无效）。
二、项目属性（作用于 Flex 项目）
    order
值：<integer>（默认 0）
作用：定义项目的排列顺序，数值越小越靠前。
    flex-grow
值：<number>（默认 0，不放大）
作用：定义项目的放大比例，剩余空间按比例分配。
    flex-shrink
值：<number>（默认 1，等比收缩）
作用：定义项目的收缩比例，空间不足时按比例缩小。
    flex-basis
值：<length>（如 200px）| auto（默认，项目原始尺寸）
作用：定义项目在分配多余空间前的初始大小。
    flex
值：none | <flex-grow> <flex-shrink> <flex-basis>（如 1 1 200px）
作用：flex-grow, flex-shrink, flex-basis 的简写，常用 flex: 1（等分空间）。
    align-self
值：auto（默认继承容器 align-items）| flex-start | flex-end | center | baseline | stretch
作用：覆盖容器的 align-items，单独定义当前项目的交叉轴对齐方式。
难点注意  flex: 1  === flex: 1 1 0%  <!-- 放大1 缩小1 告诉浏览器不考虑我的尺寸 -->
         flex: auto  === flex: 0 1 auto  <!-- 放大1 缩小1 以项目元素为默认尺寸 -->
         flex: none  === flex: 0 0 auto  <!-- 不允许放大 不允许缩小 以项目元素为默认尺寸 -->


# js事件执行顺序个人理解

- 简单来说就是 同步 -> 微任务 -> 宏任务
- 深度理解：
    执行同步代码，清空调用栈。
    检查微任务队列，清空所有微任务。不管某微任务嵌套多少层，遇微追加微队尾，遇宏追加宏队尾，遇同步直接执行
    取出宏任务队列中的第一个任务执行。不管某宏任务嵌套多少层，遇微追加微队尾，遇宏追加宏队尾，遇同步直接执行

JavaScript 是单线程的，所有同步代码（如变量声明、函数调用）会立即执行，形成执行栈（Call Stack）
宏任务队列看似是“先进先出”，但实际存在隐性优先级规则
1. 宏任务类型与优先级排序
从高到低依次为：

    UI渲染（如浏览器重绘/回流）
    I/O操作（如文件读取、AJAX响应）
    requestAnimationFrame（动画帧更新）
    setTimeout/setInterval（定时器）
    setImmediate（Node.js特有，优先级高于定时器）
    process.nextTick（Node.js微任务，但优先级高于所有宏任务）
2. 浏览器与Node.js的差异
浏览器：
    UI渲染可能插入在两次宏任务之间。
    requestAnimationFrame 专为动画设计，比定时器更频繁触发。
Node.js：
    process.nextTick 是微任务，但优先级高于 Promise。
    setImmediate 是宏任务，但优先级高于 setTimeout


# js垃圾回收机制 底层原理
JavaScript 的垃圾回收（Garbage Collection, GC）机制是自动内存管理的重要组成部分，其底层原理主要基于**标记-清除（Mark-and-Sweep）**算法和**分代回收（Generational Collection）**策略。以下是其核心工作机制的详细解析：


### 1. 垃圾回收的基本目标
JavaScript 是**动态类型语言**，变量的生命周期由运行时决定，而非开发者显式管理。垃圾回收的目标是自动识别并回收不再使用的内存，防止内存泄漏。


### 2. 标记-清除算法（Mark-and-Sweep）
这是 JavaScript 垃圾回收的核心算法，分为两个阶段：

#### 标记阶段（Marking）
- **根对象（Root）扫描**：
  - 从全局对象（如 `window` 或 `global`）、活动函数的调用栈、本地变量表等“根对象”开始。
  - 递归遍历所有从根对象可达的对象，标记为“活动”。
- **可达性分析**：
  - 如果一个对象无法通过根对象或活动链访问，则被标记为“垃圾”。

#### 清除阶段（Sweeping）
- 遍历堆内存，释放所有未被标记的对象。
- 清除后，可能会留下**内存碎片**，导致后续分配大对象时需要额外操作。

### 3. 分代回收策略（Generational Collection）
现代 JavaScript 引擎（如 V8）将内存分为**新生代（Young Generation）**和**老生代（Old Generation）**，针对不同生命周期的对象采用不同策略。

#### 新生代（Scavenge 算法）
- **特点**：
  - 存储生命周期较短的对象（如函数局部变量）。
  - 空间较小，回收频率高。
- **算法**：
  - 使用 **Cheney 算法**（一种复制算法）：
    1. 将新生代分为两个半区（From 和 To）。
    2. 活动对象从 From 空间复制到 To 空间。
    3. 交换 From 和 To 空间，清空原 From 空间。
  - 经过多次复制后仍存活的对象会被晋升到老生代。

#### 老生代（Mark-Sweep-Compact 算法）
- **特点**：
  - 存储生命周期较长的对象（如全局对象、闭包中的变量）。
  - 空间较大，回收频率低。
- **算法**：
  1. **标记-清除**：标记活动对象，清除垃圾对象。
  2. **标记-整理（Mark-Compact）**：
     - 清除后，将活动对象移动到内存一端，压缩内存，避免碎片化。

### 4. 增量标记与并行回收
为了减少垃圾回收对程序性能的影响，现代引擎采用以下优化：
- **增量标记**：
  - 将标记阶段拆分为多个小步骤，与程序执行交替进行，避免长时间阻塞。
- **并行回收**：
  - 使用多线程并行执行标记或清除操作，提高效率。

### 5. 大对象的特殊处理
- **大对象（Large Objects）**：
  - 超过一定大小的对象（如大数组、长字符串）会直接分配到老生代，避免频繁复制。
- **老生代中的大对象**：
  - 使用专门的内存管理策略，如空闲链表（Free List）来分配和回收。

### 6. 弱引用与终结器
- 弱引用（Weak Refs）：
  - 通过 `WeakMap` 和 `WeakSet` 创建弱引用对象，不会阻止垃圾回收。
- 终结器（Finalizers）：
  - 对象被回收前可以注册一个回调函数（如 `__finalize__`），但性能开销较大，不推荐频繁使用。

### 7. 触发垃圾回收的条件
垃圾回收通常由以下条件触发：
- **内存分配失败**：当新对象无法分配内存时，触发垃圾回收。
- **定时触发**：引擎会定期检查内存使用情况，主动触发回收。
- **显式调用**：开发者可以通过 `window.gc()`（仅限某些环境，如 Chrome DevTools）手动触发回收（不推荐）。

### 8. 常见内存泄漏场景
即使有垃圾回收机制，开发者仍需注意以下内存泄漏场景：
- **闭包**：闭包会持有外部函数的变量引用，可能导致无法回收。
- **全局变量**：全局变量会一直存在于内存中，直到页面关闭。
- **事件监听器**：未移除的事件监听器会阻止 DOM 元素被回收。
- **定时器**：未清除的定时器会持有回调函数的引用。

### 9. 性能优化建议
- **避免全局变量**：尽量使用局部变量或块级作用域（`let`/`const`）。
- **及时清理事件监听器**：在组件销毁时移除事件监听器。
- **使用弱引用**：对于可能被大量创建且生命周期较短的对象，使用 `WeakMap` 或 `WeakSet`。
- **分析内存使用**：使用 Chrome DevTools 的 Memory 面板分析内存快照，定位内存泄漏。

### 10. 现代引擎的优化
- **V8 引擎**：
  - 使用 **Ignition 解释器** 和 **TurboFan 编译器** 优化代码执行。
  - 针对数组等常见数据结构进行特殊优化（如 Fast-OOB）。
- **其他引擎**：
  - SpiderMonkey（Firefox）和 JavaScriptCore（Safari）也采用了类似的分代回收和增量标记策略。

### 总结
JavaScript 的垃圾回收机制通过标记-清除算法和分代回收策略，实现了高效的内存管理。开发者无需手动管理内存，但需要了解常见的内存泄漏场景，并遵循最佳实践来优化性能。现代引擎的优化技术（如增量标记、并行回收）进一步减少了垃圾回收对程序的影响。

## vue中
1. 组件切换与销毁机制
当 Vue 切换组件时，可能涉及以下两种情况：

条件渲染（如 v-if）：组件从 DOM 中移除时，会被销毁。
动态组件（如 <component :is="...">）：切换组件时，旧组件会被卸载，新组件被挂载。
关键点：

Vue 会调用组件的 beforeDestroy 和 destroyed 生命周期钩子。
组件实例被销毁后，其 DOM 元素、事件监听器、子组件等都会被清理。
2. 垃圾回收与内存释放
Vue 本身不会直接管理内存释放，而是依赖浏览器的垃圾回收机制（GC）。以下是垃圾回收的核心概念：

2.1 引用计数与可达性分析
引用计数：现代浏览器（如 V8）已不依赖简单的引用计数，而是使用更复杂的 可达性分析。
根对象（如全局变量、活动函数调用栈）是可达的起点。
如果一个对象无法从根对象访问，则被标记为垃圾。
分代回收：
浏览器将内存分为 新生代 和 老生代。
新创建的对象（如组件实例）通常进入新生代，经过多次回收后存活的对象会被移动到老生代。
2.2 组件销毁后的内存释放
当 Vue 销毁组件时：
解除 DOM 引用（如 $el）。
移除事件监听器。
清理定时器、异步任务等。
递归销毁子组件。
浏览器垃圾回收器会扫描这些被销毁的对象，如果它们不再被引用，则会释放内存。
3. 常见内存泄漏场景
在 Vue 组件切换时，以下情况可能导致内存泄漏：

事件监听器未移除：
例如，通过 addEventListener 添加的事件监听器未在 beforeDestroy 中移除。
定时器未清理：
使用 setInterval 或 setTimeout 创建的定时器未在组件销毁时清除。
循环引用：
如果组件实例与外部对象（如全局变量）形成循环引用，可能导致对象无法被回收。
缓存未清理：
如果组件中缓存了大量数据（如 data 中的大对象），且未在销毁时清理，可能导致内存占用过高。


