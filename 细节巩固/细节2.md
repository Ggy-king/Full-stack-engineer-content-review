# http3的了解

HTTP/3 概述及深入理解
  HTTP/3 是互联网协议栈的一次重大革新，其核心是 QUIC（Quick UDP Internet Connections） 协议。与 HTTP/2 基于 TCP/TLS 的架构不同，HTTP/3 彻底抛弃了 TCP，转而采用 UDP 作为传输层协议，并通过 QUIC 实现了 TCP 的所有核心功能（如可靠传输、拥塞控制）以及更多创新特性。

我的理解：为什么需要 HTTP/3？
1. TCP 的局限性：
    队头阻塞（HOL Blocking）：TCP 的流式传输虽然支持多路复用，但所有流共享一个连接，任何一条流的阻塞都会影响其他流。例如，在 HTTP/2 中，如果某个大文件请求阻塞，其他小请求（如 CSS/JS）也会被拖慢。
    连接迁移困难：现代设备（如手机）频繁切换网络（Wi-Fi → 4G → 5G），TCP 的连接基于 IP 和端口绑定，切换后必须重新建立连接，导致延迟增加。
高延迟网络性能差：TCP 的三次握手和慢启动机制在长距离或高丢包网络中效率低下。
2. QUIC 的优势：
    0-RTT 握手：通过 QUIC 内置的 TLS 1.3，客户端在首次连接时即可发送加密数据，无需等待握手完成。
    独立流控制：每个 QUIC 流都有独立的拥塞控制和重传机制，一条流的阻塞不会影响其他流。
    连接迁移：QUIC 的连接 ID 与 IP/端口解耦，设备切换网络时只需更新连接 ID，无需重新握手。
3. HTTP/2 与 HTTP/3 的对比

  HTTP/2 是基于 TCP 和 TLS 的协议，其核心是 多路复用 和 二进制分帧。通过将 HTTP 请求和响应拆分为独立的帧，HTTP/2 实现了多条流在同一连接上的并行传输，显著提升了性能。然而，HTTP/2 的多路复用仍受限于 TCP 的特性：队头阻塞（HOL Blocking）。由于 TCP 是面向流的协议，所有流共享一个连接，任何一条流的阻塞都会影响其他流。例如，如果某个大文件请求阻塞，其他小请求（如 CSS 或 JS 文件）也会被拖慢。此外，TCP 的连接建立需要三次握手和 TLS 握手，在高延迟网络中（如移动网络）会导致明显的延迟。尽管 HTTP/2 提供了服务器推送（Server Push）和头部压缩（HPACK）等优化，但其性能仍受制于 TCP 的底层设计。

  HTTP/3 则完全抛弃了 TCP，转而采用 QUIC（Quick UDP Internet Connections） 协议作为传输层。QUIC 基于 UDP，但通过内置的可靠传输、拥塞控制和连接管理机制，实现了比 TCP 更高效的数据传输。HTTP/3 的最大优势在于 0-RTT 握手 和 流独立控制。通过 QUIC 内置的 TLS 1.3，客户端在首次连接时即可发送加密数据，无需等待握手完成，这显著减少了延迟。此外，QUIC 的每个流都有独立的拥塞控制和重传机制，一条流的阻塞不会影响其他流，彻底解决了 HTTP/2 的队头阻塞问题。HTTP/3 还支持 连接迁移，设备在网络切换（如 Wi-Fi → 4G）时无需重新握手，保持连接状态，进一步提升了用户体验。



UDP/TCP 的缺点（深入分析）
1. TCP 的缺点
队头阻塞（HOL Blocking）：
    我的理解：TCP 的流式传输本质上是串行的，即使使用多路复用，所有流仍共享一个队列。一旦某条流阻塞（如大文件下载），后续流必须等待，导致性能下降。
连接开销高：
    我的理解：TCP 的三次握手和 TLS 握手在移动网络中可能占用数百毫秒，而 HTTP/3 的 0-RTT 握手能将延迟降低到接近零。
不支持连接迁移：
    我的理解：现代设备频繁切换网络，TCP 的连接依赖 IP 和端口绑定，切换后必须重新握手，而 QUIC 的连接 ID 机制能无缝迁移连接。
扩展性差：
    我的理解：TCP 的头部固定为 20 字节，扩展字段有限，而 QUIC 的头部更灵活，支持更多自定义选项。
2. UDP 的缺点
可靠性不足：
    我的理解：UDP 是无连接的，数据包可能丢失或乱序，需要应用层实现重传和排序，增加了开发复杂度。
易受攻击：
    我的理解：UDP 没有内置加密，容易被中间人攻击，而 QUIC 内置 TLS 1.3，简化了安全机制。
    QUIC 协议的优缺点（扩展分析）
优点
低延迟：
    我的理解：QUIC 的 0-RTT 握手和流独立机制能显著减少延迟，尤其适合移动设备和实时通信（如视频通话、游戏）。
多路复用优化：
    我的理解：HTTP/2 的多路复用仍受 TCP 限制，而 HTTP/3 的流独立机制能彻底解决队头阻塞问题，提升并发性能。
连接迁移：
    我的理解：QUIC 的连接 ID 机制使得设备在网络切换时无需重新握手，减少了延迟和丢包。
前向纠错（FEC）：
    我的理解：在丢包率高的网络中，FEC 能减少重传次数，提升传输效率。例如，在卫星网络中，FEC 能将重传率降低 50% 以上。
内置加密：
    我的理解：QUIC 内置 TLS 1.3，简化了安全机制，减少了开发复杂度。
    缺点
NAT 穿透问题：
    我的理解：部分网络环境（如企业防火墙）可能限制 UDP，导致 QUIC 无法正常工作。例如，一些运营商会对 UDP 流量进行限速或丢包。
实现复杂度：
    我的理解：QUIC 的协议栈比 TCP 更复杂，需要同时优化 QUIC 和应用层逻辑。例如，浏览器和服务器需要同时支持 QUIC 和 HTTP/3，增加了开发和维护成本。
总结与未来展望

    HTTP/3 通过 QUIC 协议解决了 TCP 的根本性问题（如队头阻塞、连接迁移），并针对移动网络和全球网络环境进行了优化。
    在高延迟、高丢包网络中，HTTP/3 的性能提升尤为明显，尤其适合 5G 和物联网场景。
    挑战与未来：
    部署挑战：QUIC 的实现复杂度较高，需要浏览器、服务器和中间设备（如防火墙、负载均衡器）的全面支持。
    标准化进程：QUIC 仍在 IETF 标准化过程中，部分特性（如 0-RTT 握手的安全性）仍在完善。
    生态建设：HTTP/3 的普及需要开发者社区的积极参与，尤其是在 Web 性能优化和实时通信领域。


# JSONP的详细使用 

#### 1. 什么是 JSONP？
JSONP 是一种用于解决 **跨域请求** 的技术，主要用于浏览器环境。由于浏览器的 **同源策略**（Same-Origin Policy）限制，网页无法直接请求不同源（域名、协议、端口不同）的资源。JSONP 通过动态插入 `<script>` 标签的方式，利用 `<script>` 标签不受同源策略限制的特性，实现跨域数据获取。

---

#### 2. JSONP 的工作原理
1. 客户端请求：
   - 客户端通过动态创建一个 `<script>` 标签，设置其 `src` 属性为目标服务器的接口地址，并在 URL 中传递一个回调函数名（通常通过 `callback` 参数）。
   - 例如：`<script src="https://example.com/api?callback=handleResponse"></script>`

2. 服务器响应：
   - 服务器接收到请求后，将返回的数据包装成一个 JavaScript 函数调用，函数名即为客户端传递的回调函数名。
   - 例如：`handleResponse({ "name": "Alice", "age": 25 });`

3. 客户端执行：
   - 浏览器加载 `<script>` 标签时，会执行服务器返回的 JavaScript 代码，调用客户端定义的回调函数，并将数据作为参数传递。

---

#### 3. JSONP 的使用步骤

客户端代码示例：
```html

  <script>
    // 定义回调函数
    function handleResponse(data) {
      console.log("接收到的数据：", data);
      document.getElementById("result").innerText = "姓名: " + data.name + ", 年龄: " + data.age;
    }

    // 动态创建 <script> 标签
    function fetchData() {
      const script = document.createElement("script");
      script.src = "https://example.com/api?callback=handleResponse"; // 替换为实际接口地址
      document.body.appendChild(script);
    }
  </script>

```

服务器端响应示例（伪代码）：
```javascript
// 假设服务器接收到请求：https://example.com/api?callback=handleResponse
const callbackName = req.query.callback; // 获取回调函数名
const data = { name: "Alice", age: 25 }; // 模拟数据
const response = `${callbackName}(${JSON.stringify(data)})`; // 包装成 JSONP 格式
res.send(response);
```

---

#### 4. JSONP 的优缺点

优点：
- 简单易用：无需复杂的配置，只需动态插入 `<script>` 标签。
- 兼容性好：支持所有浏览器，包括旧版浏览器。
- 快速实现：适合快速开发跨域请求功能。

缺点：
- 安全性问题**：
  - JSONP 本质上是执行服务器返回的 JavaScript 代码，存在 **XSS（跨站脚本攻击）** 风险。
  - 如果服务器返回恶意代码，客户端会直接执行。
- 只支持 GET 请求：由于是通过 `<script>` 标签加载数据，无法发送 POST、PUT 等其他类型的请求。
- 调试困难：JSONP 的错误处理机制较弱，难以捕获请求失败的具体原因。

---

#### 5. JSONP 的安全注意事项
1. 限制回调函数名：
   - 服务器应验证回调函数名是否合法，避免执行恶意代码。
   - 例如，只允许字母、数字、下划线组成的回调函数名。

2. 使用 HTTPS：
   - 确保服务器使用 HTTPS 协议，防止数据在传输过程中被篡改。

3. 避免信任第三方数据：
   - 不要直接信任第三方返回的数据，应在回调函数中对数据进行校验。

4. 考虑替代方案：
   - 如果可能，优先使用 **CORS（跨域资源共享）** 或 **代理服务器**，这些方法更安全且功能更强大。

---

#### 6. JSONP 的适用场景
- **需要兼容旧版浏览器**：如果项目需要支持 IE8 等旧版浏览器，JSONP 是一个可行的选择。
- **快速实现跨域请求**：在开发初期或快速原型阶段，可以使用 JSONP 快速验证功能。
- **仅需 GET 请求**：如果只需要发送 GET 请求，JSONP 是一个简单的解决方案。

---

#### 7. JSONP 的替代方案
1. CORS（跨域资源共享）：
   - 通过服务器设置响应头 `Access-Control-Allow-Origin`，允许跨域请求。
   - 支持所有 HTTP 方法（GET、POST、PUT 等）。

2. 代理服务器：
   - 在同源服务器上设置一个代理，客户端请求代理服务器，代理服务器再请求目标服务器。

3. PostMessage：
   - 如果跨域请求发生在不同窗口或 iframe 之间，可以使用 `window.postMessage` 进行通信。

4. WebSockets：
   - 如果需要实时通信，可以使用 WebSockets，它不受同源策略限制。


# nextTick更加底层的逻辑是什么，是基于什么判断异步数据彻底结束的（node与vue中的一样吗）

### **`nextTick` 的底层逻辑**
`nextTick` 的核心逻辑是 **在异步任务队列中，确保回调函数在当前事件循环的同步任务和异步渲染队列执行完毕后执行**。具体来说，它的底层实现依赖于浏览器的 **事件循环机制** 和 **微任务队列**。

一句话：1 异步数据更新把相应的更新任务放入异步队列中，然后合并变化只触发一次dom更新 -> 2 同步任务完成后清空
异步队列，重新计算虚拟dom，一定注意异步队列与微任务队列不是一个东西 -> 3 nextTick注册到微任务队列在下个宏任务(也就是下一个dom事件)前执行，这样保证的此时的虚拟dom一定是当前事件循化最新的，但是可要知道的是它执行完了才会更新真实的dom

1. 异步数据更新的触发与队列管理
- 当 Vue 的响应式数据发生变化时，Vue 不会立即更新 DOM，而是将对应的更新任务放入一个 **异步队列** 中。
- 在同一个事件循环内，如果有多次数据变化，Vue 会将这些变化合并，最终只触发一次 DOM 更新。

2. 异步队列的清空与虚拟 DOM 更新
- Vue 等待当前事件循环的同步任务执行完毕后，开始清空异步队列。
- 清空队列时，Vue 会重新计算虚拟 DOM，并应用必要的更新。

3. `nextTick` 的回调注册与执行
- `nextTick` 的回调被注册到微任务队列中（通常是通过 `Promise.then` 或 `MutationObserver` 实现）。
- 微任务队列的执行时机是：
  - 在当前事件循环的同步任务完成后。
  - 在 Vue 的异步渲染队列被清空、虚拟 DOM 更新完成后。
  - **但在真实 DOM 更新之前**。

4. 为什么选择微任务？
- 微任务（如 `Promise.then`）的执行优先级高于宏任务（如 `setTimeout`），因此可以确保 `nextTick` 的回调尽可能早地执行。
- 微任务的执行时机正好符合 Vue 的需求：在虚拟 DOM 更新完成后、真实 DOM 更新之前。

---

### **Vue 如何判断异步数据彻底结束？**

Vue 通过以下机制判断异步数据更新是否彻底结束：

1. 批量更新策略：
   - Vue 会将同一个事件循环内的多次数据变化合并为一次更新任务，避免频繁的 DOM 操作。
   - 这种批量更新策略确保了异步数据更新的“彻底性”。

2. 异步队列的清空：
   - Vue 使用一个内部的异步队列来管理所有的 DOM 更新任务。
   - 当异步队列被清空时，意味着所有异步数据更新任务已经处理完毕。

3. 微任务队列的执行：
   - `nextTick` 的回调被注册到微任务队列中，只有在异步队列被清空后，微任务队列才会被执行。
   - 因此，`nextTick` 的回调执行时，可以确保所有异步数据更新任务已经彻底结束。

---

### **Vue 的 `nextTick` 与 Node.js 的 `nextTick` 有什么区别？**

1. 底层实现
- **Vue 的 `nextTick`**：
  - 依赖于浏览器的微任务队列（如 `Promise.then` 或 `MutationObserver`）。
  - 在浏览器环境中，`Promise.then` 是最常用的实现方式。
  - 如果浏览器不支持 `Promise`，Vue 会降级使用 `MutationObserver` 或 `setTimeout`。

- Node.js 的 `nextTick`：
  - 是 Node.js 特有的机制，直接由 Node.js 的事件循环实现。
  - `process.nextTick` 的回调会在当前事件循环的 I/O 阶段之后、`setImmediate` 之前执行。

2. 使用场景
- Vue 的 `nextTick`：
  - 用于在 DOM 更新完成后执行回调，确保回调函数可以访问到最新的虚拟 DOM 状态。
  - 典型场景：在数据变化后，需要操作 DOM 或获取 DOM 的最新状态。

- Node.js 的 `nextTick`：
  - 用于在当前事件循环的 I/O 阶段之后立即执行回调。
  - 典型场景：在异步操作完成后，需要立即执行一些逻辑，但又不想阻塞当前事件循环。

**3. 执行时机
- Vue 的 `nextTick`：
  - 在异步渲染队列被清空、虚拟 DOM 更新完成后执行。
  - 但在真实 DOM 更新之前。

- Node.js 的 `nextTick`：
  - 在当前事件循环的 I/O 阶段之后、`setImmediate` 之前执行。
  - 与 Vue 的 `nextTick` 执行时机不同。

---

### **总结**

- Vue 的 `nextTick`：
  - 基于浏览器的微任务队列实现。
  - 在异步渲染队列被清空、虚拟 DOM 更新完成后执行回调。
  - 确保回调函数可以访问到最新的虚拟 DOM 状态，但在真实 DOM 更新之前。

- Node.js 的 `nextTick`：
  - 是 Node.js 特有的机制，与事件循环紧密相关。
  - 在当前事件循环的 I/O 阶段之后、`setImmediate` 之前执行回调。

两者的核心区别在于 **底层实现** 和 **使用场景**，但它们都遵循了 **“在当前事件循环的某个阶段之后立即执行回调”** 的设计理念。


# 连续的函数调用(同步异步混搭)具体的实现方法有哪些