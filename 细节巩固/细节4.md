一、js的基础知识点介绍
js作为浏览器脚本语言，它的主要用途是与用户互动，以及操作DOM，因此js是单线程，也避免了同时操作同一个DOM的矛盾问题;
为了利用多核CPU的计算能力，H5的Web Worker实现的“多线程”实际上指的是“多子线程”，完全受控于主线程，且不允许操作DOM;
js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop(事件循环);
所有同步任务都在主线程上执行，形成一个执行栈(execution context stack);
如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行;
二、相关概念
1、JS为什么是单线程的?
JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢?这样能提高效率啊。
JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准?
所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变;
为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质;
2、JS为什么需要异步?
如果JS中不存在异步，只能自上而下执行，如果上一行解析时间很长，那么下面的代码就会被阻塞。对于用户而言，阻塞就意味着"卡死"，这样就导致了很差的用户体验;

3、JS单线程又是如何实现异步的呢?
既然JS是单线程的，只能在一条线程上执行，又是如何实现的异步呢?

是通过的事件循环(event loop)，理解了event loop机制，就理解了JS的执行机制。

4、任务队列
"任务队列"是一个事件的队列(也可以理解成消息的队列)，IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件;
"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件(比如鼠标点击、页面滚动等等)。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。
所谓"回调函数"(callback)，就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数;
"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。
读取到一个异步任务，首先是将异步任务放进事件表格(Event table)中，当放进事件表格中的异步任务完成某种事情或者说达成某些条件(如setTimeout事件到了，鼠标点击了，数据文件获取到了)之后，才将这些异步任务推入事件队列(Event Queue)中，这时候的异步任务才是执行栈中空闲的时候才能读取到的异步任务;
5、Event Loop
主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop(事件循环);
Event Loop是javascript的执行机制
6、setTimeout(fn,0)
setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。
HTML5标准规定了setTimeout()的第二个参数的最小值(最短间隔)，不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动(尤其是涉及页面重新渲染的部分)，通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。
需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码(执行栈)执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行
三、js执行机制介绍
1、javascript的同步和异步
单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。
如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备(输入输出设备)很慢(比如Ajax操作从网络读取数据)，不得不等着结果出来，再往下执行。
JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
于是，所有任务可以分成两种，一种是同步任务(synchronous)，另一种是异步任务(asynchronous)。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务;异步任务指的是，不进入主线程、而进入"任务队列"(task queue)的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。


同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。
当Event Table中指定的事情完成时，会将这个函数移入Event Queue。
主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
上述过程会不断重复，也就是常说的Event Loop(事件循环)。
我们不禁要问了，那怎么知道主线程执行栈为空啊?js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数;
2、JavaScript的宏任务与微任务
你是否觉得同步异步的执行机制流程就是JavaScript执行机制的全部?不是的，JavaScript除了广义上的的同步任务何异步任务，其对任务还有更精细的定义：

macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
micro-task(微任务)：Promise，process.nextTick
不同类型的任务会进入对应的Event Queue。

事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。


### JavaScript引擎
JavaScript引擎是执行JavaScript代码的程序。常见的JavaScript引擎包括Google的V8（用于Chrome和Node.js）、Mozilla的SpiderMonkey（用于Firefox）和Apple的JavaScriptCore（用于Safari）。引擎负责解析、编译和执行JavaScript代码。
那么我们都知道计算机只认0和1。一段代码想要被执行，是必须要把高级语言转换成低级语言（能间接控制硬件行为），使其能被机器识别后才会执行的。但其实说白了，转换的过程用的也是一段程序，而这段程序我们喜欢把它叫作引擎。
大部分JS引擎采用JIT技术
JIT（Just-In-Time即时编译） 是一种编程语言执行方式，它在程序运行时将代码编译为机器代码，而不是在程序启动时提前编译（如传统的编译方式）或逐行解释（如解释型语言）。JIT编译器结合了编译和解释的优点，可以提高代码的执行效率，尤其是在动态语言（如JavaScript、Java等）中表现得尤为明显。
以v8引擎（由Google开发，没错就叫v8）展开讲，v8引擎是一个接收JavaScript代码，编译代码然后执行的c++程序，编译后的代码可以在多种操作系统、多种处理器上运行。 V8引擎要负责以下工作：JS代码的编译和执行、处理调用栈（这个会重点讲）、内存的分配和垃圾的回收。
它把代码的运行和生成可执行的代码这两个过程结合在了一起，在运行阶段收集信息，然后根据这些信息生成机器码，最后再执行机器码（这个过程一般会被重复多次）。

JS代码的执行步骤（先作了解）
从源代码到最终执行，主要包括以下阶段：
1. 词法分析（Lexical Analysis）
将源代码文本分解成一个个标记（tokens）。
javascript 代码解读复制代码let sum = 1 + 2;

// 词法分析后的标记
[
    { type: 'keyword', value: 'let' },
    { type: 'identifier', value: 'sum' },
    { type: 'operator', value: '=' },
    { type: 'number', value: '1' },
    { type: 'operator', value: '+' },
    { type: 'number', value: '2' },
    { type: 'punctuator', value: ';' }
]

2. 语法分析（Syntax Analysis/Parsing）
将标记转换为抽象语法树（AST）。
3. 预编译阶段
在代码执行之前的准备工作。


创建执行上下文


变量提升（这个特性并不好）


javascript 代码解读复制代码// 原代码
console.log(a);
var a = 2;

// 预编译后的实际执行顺序
var a;
console.log(a); // undefined
a = 2;

4. 字节码生成
将AST转换为字节码（以V8引擎为例）。
javascript 代码解读复制代码// 伪字节码示例
LdaConstant [0]    // 加载常量1
Add a1             // 加法操作
Star r0           // 存储结果

5. 执行阶段
代码实际运行的阶段。


解释执行


JIT编译


6. 运行时优化


内联缓存（Inline Caching）


类型反馈（Type Feedback）


记录参数类型信息以优化后续调用
7.垃圾回收
JavaScript引擎还负责管理内存，自动清理不再使用的内存空间。垃圾回收机制会周期性地执行，以避免内存泄漏和其他内存相关的问题。
8. 事件循环（Event Loop）
负责处理异步操作和事件。事件循环的主要任务是监控调用栈和任务队列，并将任务从队列中移动到调用栈中执行。
9. 错误处

作者：PW
链接：https://juejin.cn/post/7442499057991630848
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。